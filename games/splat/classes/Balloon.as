import flash.geom.Point;import mx.transitions.Tween;import mx.utils.Delegate;//class Balloon {	//	private var manager:BalloonManager;	private var clip:MovieClip;	private var balloonClip:MovieClip;	private var txtfield:TextField;	private var letter:String;	private var popped:Boolean;	private var dragging:Boolean;	private var dest:Point;	private var destroyed:Boolean;	private var paused:Boolean;	//	private var newDestInterval:Number;	private var maxSpeed:Number;	private var friction:Number;	private var newDestPause:Number;	private var textFmt;	//	public function Balloon(manager:BalloonManager, holder:MovieClip, index:Number, letter:String, depth:Number) {		this.manager = manager;		this.letter = letter;		//		popped = false;		dragging = false;		maxSpeed = 60;		textFmt = new TextFormat("Arial", 32, 0xFFFFFF, true);		//		clip = holder.createEmptyMovieClip("balloon_"+index, depth);		txtfield = clip.createTextField("txtfield", 0, 10, 0, 0, 0);		clip.txtfield.autoSize = true;		clip.txtfield.selectable = false;		clip.txtfield.setNewTextFormat(textFmt);		clip.txtfield.text = letter;		clip.attachMovie("balloon_"+random(4), "balloon", 1);		clip._x = 300;		clip._y = 100;		clip._alpha = 70;		destroyed = false;		paused = false;		//		clip.gotoAndPlay("balloon");		dest = new Point(300, 100);		setNewDestPause();		setNewFriction();		//		resetInterval();		clip.onEnterFrame = Delegate.create(this, moveBalloon);		clip.balloon.onPress = Delegate.create(this, popBalloon);	}	private function moveBalloon():Void {		if (!dragging && !paused) {			clip._x += (dest.x - clip._x) / friction;			clip._y += (dest.y - clip._y) / friction;		}	}	private function setNewDest():Void {		if (destroyed) {			clearInterval(newDestInterval);			delete this;			return;		} else {			setNewDestPause();		}				// Search for random X and Y values that stay in the boundaries of the game		var searchingForX:Boolean = true;		var counterX:Number = 0;		var counterLimit = 15;		while (searchingForX) {			searchingForX = false;			var randomX:Number = getNewX();			if (randomX < 0 || randomX > (600 - clip._width)) {				searchingForX = true;			} else {				dest.x = Math.round(randomX);			}			counterX++;			if (counterX > counterLimit) {				dest.x = 150;			}		}		var searchingForY:Boolean = true;		var counterY:Number = 0;		while (searchingForY) {			searchingForY = false;			var randomY:Number = getNewY();			if (randomY < 0 || randomY > (300 - clip._height)) {				searchingForY = true;			} else {				dest.y = Math.round(randomY);			}			counterY++;			if (counterY > counterLimit) {				dest.y = 150;			}		}	}	private function popBalloon():Void {		clip.balloon.gotoAndPlay("pop");		popped = true;		clip.onPress = Delegate.create(this, dragLetter);		clip.onRelease = Delegate.create(this, dropLetter);	}	private function dragLetter():Void {		clip.startDrag();		dest.x = clip._x;		dest.y = clip._y;		clearInterval(newDestInterval);		dragging = true;	}	private function dropLetter():Void {		clip.stopDrag();		manager.evaluate(this);		resetInterval();		dragging = false;	}	public function destroy():Void {		if (!destroyed) {			removeMovieClip(clip);			delete clip.onEnterFrame;			delete clip.onRelease;			newDestInterval = 0;			clearInterval(newDestInterval);			newDestPause = 0;			clearInterval(newDestPause);			destroyed = true;		}	}	//	public function getClip():MovieClip {		return clip;	}	private function resetInterval():Void {		newDestInterval = setInterval(Delegate.create(this, setNewDest), newDestPause);	}	private function getNewX():Number {		return clip._x + -maxSpeed + Math.random() * 2 * maxSpeed;	}	private function getNewY():Number {		return clip._y + -maxSpeed + Math.random() * 2 * maxSpeed;	}	private function setNewDestPause():Void {		newDestPause = 2500 + Math.random() * 3000;	}	private function setNewFriction():Void {		friction = 40 + Math.random() * 10;	}		public function pauseBalloon():Void {		paused = true;	}	public function resumeBalloon():Void {		paused = false;	}}