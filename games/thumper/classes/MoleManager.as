import mx.utils.Delegate;import flash.geom.Point;//class MoleManager {	//	private var moles:Array;	private var activeMoles:Array;	private var popUpDelay:Number;	private var maxMoles:Number;	//	public function MoleManager(ques:Array) {		activeMoles = new Array();		moles = new Array();		maxMoles = 20;		createMoles(ques);		popUpDelay = setInterval(this, "popUpMole", 750);	}		public function createMoles(ques:Array):Void {		var counter:Number = 0;		for (var i:Number = 0; i < ques.length; i++) {			var tmp:Mole = new Mole(ques[i], counter, this);			moles.push(tmp);			if ((i == ques.length - 1) && moles.length < maxMoles) {				i = -1;			}			counter++;		}	}		public function popUpMole():Void {		var rndm:Number = Math.floor(Math.random() * moles.length);		var nextMole:Mole = moles[rndm];		if (!nextMole.isShowing()) {			var searching:Boolean = true;			var counter:Number = 0;			while (searching) {								var newPt:Point = nextMole.calcNewPosition();				var overlapping:Boolean = false;				for (var i:Number = 0; i < activeMoles.length; i++) {					var compMole:Mole = activeMoles[i];					if (newPt.x >= compMole.getLeftSide() && newPt.x <= compMole.getRightSide()) {						if (newPt.y >= compMole.getTopSide() && newPt.y <= compMole.getBottomSide()) {							overlapping = true;						}					}				}				if (!overlapping) {					searching = false;				} else {					trace("found an overlap! searching again... "+counter);					counter++;				}			}			nextMole.setNewPosition(newPt.x, newPt.y);			nextMole.popUp();			activeMoles.push(nextMole);		}	}	public function deactivateMole(m:Mole):Void {		for (var i:Number = 0; i < activeMoles.length; i++) {			if (activeMoles[i] == m) {				activeMoles.splice(i, 1);			}		}	}	public function destroy():Void {		clearInterval(popUpDelay);		for (var i:Number = 0; i < moles.length; i++) {			moles[i].destroy();		}		delete this;	}		public function hit(attempt:Object):Void {		LZGame.getInstance().evaluate(attempt);	}}