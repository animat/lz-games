import mx.utils.Delegate;import mx.transitions.Tween;import flash.geom.Point;class Balloon {	private var clip:MovieClip;	private var correct:Boolean;	private var option:Option;	private var optionDisplay:StimulusDisplay;	private var bowAndArrow:BowAndArrow;		private var popped:Boolean;	private var renew:Boolean;	private var resetAfterFly:Boolean;	private var orig:Point;	private var target:Point;		private var totalShift:Number;	private var shiftUnit:Number;	private var xMagnitude:Number;	private var xFrequency:Number;	private var initialDirection:Number;	private var ySpeed:Number;	private var paused:Boolean;		public function Balloon(holder:MovieClip, id:Number, option:Option, bowAndArrow:BowAndArrow) {		clip = holder.attachMovie("balloon", "balloon_"+id, holder.getNextHighestDepth());		this.option = option;		optionDisplay = new StimulusDisplay(clip, "optionDisplay", option.getStimulus());		optionDisplay.setPos(-25, -63);		this.bowAndArrow = bowAndArrow;		correct = false;		renew = true;		resetAfterFly = true;		paused = false;				reset();		clip.onEnterFrame = Delegate.create(this, float);	}		private function float():Void {		if (!paused) {			checkForShot();			clip._x = orig.x + initialDirection * xMagnitude * Math.sin(Math.PI / xFrequency * (orig.y - clip._y));			totalShift += shiftUnit;			clip._x += totalShift;			clip._y -= ySpeed;			if (clip._y < -clip._height && resetAfterFly) {				reset();			}		}	}		private function checkForShot():Void {		if (bowAndArrow.isFired() && !bowAndArrow.hasBounced()) {			if (clip.balloonhead.hitTest(bowAndArrow.getArrowClip().arrowhead)) {				RunGame.getInstance().evaluate(this);			}		}	}		public function reset():Void {		if (renew) {			var startX:Number = ((Math.random() * 100) > 50) ? -25 : 625;			orig = new Point(startX, 330);			clip._x = orig.x;			clip._y = orig.y;			clip._alpha = 100;			clip.gotoAndPlay(Math.round(Math.random()*22));			var tmp:Number = 1 + Math.floor(Math.random() * clip.tail._totalframes - 1);			clip.tail.gotoAndPlay(tmp);			optionDisplay.show();			popped = false;			resetAfterFly = true;			ySpeed = 1 + Math.random() * 1.5;			xMagnitude = 25 + Math.random() * 10;			xFrequency = 70 + Math.random() * 30;			initialDirection = (Math.random() * 100 > 50) ? 1 : -1;			totalShift = 0;			shiftUnit = (target.x - orig.x) / (orig.y/ySpeed);		} else {			destroy();		}	}		public function flyAway():Void {		new Tween(clip, "_y", mx.transitions.easing.Regular.easeIn, clip._y, clip._y - 400, 2, true);		new Tween(clip, "_alpha", mx.transitions.easing.Regular.easeIn, 100, 0, 1, true);		optionDisplay.hide();		resetAfterFly = false;	}		public function flyAwayAndReset():Void {		var twn:Tween = new Tween(clip, "_y", mx.transitions.easing.Regular.easeIn, clip._y, clip._y - 600, 2, true);		optionDisplay.hide();		resetAfterFly = true;		twn.onMotionFinished = Delegate.create(this, reset);	}		public function destroy():Void {		delete clip.onEnterFrame;		removeMovieClip(clip);		delete this;	}		public function popBalloon():Void {		clip.gotoAndPlay("pop");		optionDisplay.hide();	}		public function setRenew(val:Boolean):Void {		renew = val;	}	public function setTarget(targ:Point):Void {		target = targ;		shiftUnit = (targ.x - orig.x) / (orig.y/ySpeed);	}	public function setCorrect(val:Boolean):Void {		correct = val;	}	public function isCorrect():Boolean {		return correct;	}	public function getClip():MovieClip {		return clip;	}	public function getOption():Option {		return option;	}		public function pauseBalloon():Void {		paused = true;	}	public function resumeBalloon():Void {		paused = false;	}}