import mx.utils.Delegate;class TimelineManager {	private static var interval:Number = 500;	private static var intervalID:Number;	private static var mcs:Array = [];	//	// Register a movie clip and a passed in callback param to the array	public static function registerClip(newClip:MovieClip, callbackObj:Object, newCallback:Function, newArgs:Array, newLabel:String):Void {		var frame:Number = (newLabel == null || newLabel == undefined) ? 1 : findEndFrame(newClip, newLabel);		var callback:Function = Delegate.create(callbackObj, newCallback);		mcs.push({clip: newClip, callback: callback, args: newArgs, endFrame: frame});		runInterval();	}	//	// Pause all of the clips currently listed in the TimelineManager	public static function pauseAllClips():Void {		for (var i:Number = 0; i < mcs.length; i++) {			mcs[i].stop();		}	}	//	// Resume all of the clips listed in the TimelineManager	public static function resumeAllClips():Void {		for (var i:Number = 0; i < mcs.length; i++) {			mcs[i].play();		}	}	//	// Set up the checkClips() to happen at a regulated interval	private static function runInterval():Void {		intervalID = setInterval(checkClips, interval);	}	//	// Check each timeline in the array to see if the animation is done	//	// *****POTENTIAL BUG: when the arguments are joined, all arguments are converted to strings!******	//	private static function checkClips():Void {		if (mcs.length > 0) {			for (var i:Number = 0; i < mcs.length; i++) {				if (mcs[i].clip._currentframe == mcs[i].endFrame) {					mcs[i].callback(mcs[i].args.join(", "));					removeClip(i);				}			}		}	}	//	//~~~~~~~~~~~~~~~~	//	// Helper functions	private static function findEndFrame(mc:MovieClip, lbl:String):Number {		var dup:MovieClip = mc.duplicateMovieClip("dummy", mc._parent.getNextHighestDepth());		dup._visible = false;		dup.gotoAndStop(lbl);		var frame:Number = dup._currentframe;		dup.removeMovieClip();		return frame;	}	private static function removeClip(index:Number) {		mcs.splice(index, 1);		if (mcs.length == 0) {			clearInterval(intervalID);		}	}}