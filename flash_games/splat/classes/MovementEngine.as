import mx.utils.Delegate;class MovementEngine {	private var classScope:Object;		private var clip:MovieClip;	private var finalX:Number, finalY:Number;	private var popped:Boolean;	private var dragging:Boolean;		private var newDestInterval:Number;	private var maxSpeed:Number = 60;	private var friction:Number;	private var newDestPause:Number;		private static var textFormatting = new TextFormat("Arial", 32, 0xFFFFFF, true);	private static var WIDTH = 600;	private static var HEIGHT = 300;		public function MovementEngine(classScope:Object, clip:MovieClip) {		this.classScope = classScope;				this.clip = clip;		clip.gotoAndPlay("balloon");		popped = false;		dragging = false;				setNewDestPause();		setNewFriction();				resetInterval();		clip.onEnterFrame = Delegate.create(this, moveBalloon);		clip.balloon.onPress = Delegate.create(this, popBalloon);	}		//***As long as the clip isn't being dragged, ease towards the destination points	private function moveBalloon():Void {		if (!dragging) {			clip._x += (finalX - clip._x) / friction;			clip._y += (finalY - clip._y) / friction;		}	}		//***Get a new random pause amount, get random X and Y destination points	private function setNewDest():Void {		setNewDestPause();				// Search for random X and Y values that stay in the boundaries of the game		var searchingForX:Boolean = true;		var counterX:Number = 0;		var counterLimit = 25;		while (searchingForX) {			searchingForX = false;			var randomX:Number = getNewX();			if (randomX < 0 || randomX > (WIDTH - clip._width)) {				searchingForX = true;			} else {				finalX = randomX;			}			counterX++;			if (counterX > counterLimit) {				finalX = 150;			}		}		var searchingForY:Boolean = true;		var counterY:Number = 0;		while (searchingForY) {			searchingForY = false;			var randomY:Number = getNewY();			if (randomY < 0 || randomY > (HEIGHT - clip._height)) {				searchingForY = true;			} else {				finalY = randomY;			}			counterY++;			if (counterY > counterLimit) {				finalY = 150;			}		}	}		//***Pop the balloon, allow letters to be clicked and dragged***	private function popBalloon():Void {		clip.balloon.gotoAndPlay("pop");		popped = true;		clip.onPress = Delegate.create(this, dragLetter);		clip.onRelease = Delegate.create(this, dropLetter);	}		//***Drag and drop functionality for letters***	private function dragLetter():Void {		clip.startDrag();		finalX = clip._x;		finalY = clip._y;		clearInterval(newDestInterval);		dragging = true;	}	private function dropLetter():Void {		clip.stopDrag();		// Check to see if user has dropped correct letter in correct place		//var currentQuestion:Question = classScope.questionsList[classScope.qNum];		//var checkAnswer:CheckAnswer = new CheckAnswer(classScope, currentQuestion, clip);		if (checkAnswer.checkUserInput()) {			clip._visible = false;			delete this;			delete clip;			checkAnswer.correctAnswer();			clearInterval(newDestInterval);		} else {			checkAnswer.wrongAnswer();		}		resetInterval();		dragging = false;	}		//***Getter and setter functions***	private function resetInterval():Void {		newDestInterval = setInterval(Delegate.create(this, setNewDest), newDestPause);	}	private function getNewX():Number {		return clip._x + -maxSpeed + Math.random() * 2 * maxSpeed;	}	private function getNewY():Number {		return clip._y + -maxSpeed + Math.random() * 2 * maxSpeed;	}	private function setNewDestPause():Void {		newDestPause = 2500 + Math.random() * 3000;	}	private function setNewFriction():Void {		friction = 40 + Math.random() * 10;	}}